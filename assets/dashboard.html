<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>ASS - Dashboard</title>
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="description" content="" />
    <link href="https://cdn.jsdelivr.net/npm/modern-normalize@v3.0.1/modern-normalize.min.css" rel="stylesheet">
    <link rel="icon" href="static/img/logo_16.png" />
    <!-- Used for cookie manipulation -->
    <script src="https://cdn.jsdelivr.net/npm/js-cookie@3.0.1/dist/js.cookie.min.js"></script>
    <!-- Used for token cookie refresh/ping -->
    <script src="static/js/tokenrefresh.js"></script>
    <!-- CSS -->
    <link rel="stylesheet" href="/static/css/globaldefaults.css" />
    <style>
        .menuheader {
            /* position:absolute;left:50%;transform:translate(-50%,0); */
            border-bottom: solid white;font-size:150%;
        }
        .maincenter {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        .card {
            width: 95%;
            background-color: black;
            margin: auto;
            margin-bottom: 5px;
            position:relative;
            border-radius: 5px;
        }
        .accountcard {
            height: 100px;
            cursor: pointer;
        }
        .selectedaccount {
            border: 1px solid #1ed760;
        }
        .selectedsort1 {
            border: #1ed760 1px solid;
        }
        .selectedsort-1 {
            border: red 1px solid;
        }
        .sortcard {
            height: 50px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="root">
        <div id="header">
            <img id="logoimg" class="navbarlogo" src="/static/img/logo_120.png" onclick="window.location.href='/';" />
            <a href="/logout" class="navbarlogout">
                Logout
            </a>
        </div>
        <div id="main">
            <div id="main2">
                <div id="mainacct" class="maincenter" style="width:22%;height:100%;background-image:linear-gradient(120deg, #555555, #1a1a1a);border-radius:20px;position:relative;">
                    <p class="menuheader">Account</p>
                    <div id="mainacctinner" style="width:calc(100% - 20px);height:100%;background-color:#1a1a1a;border-radius:20px;margin-bottom:10px;padding-top:25px;overflow-y:auto;"></div>
                </div>
                <div id="mainmiddle" style="width:22%;height:100%;">
                    <div id="mainfilters" class="maincenter" style="width:100%;height:49.5%;background-image:linear-gradient(120deg, #555555, #1a1a1a);border-radius:20px;position:relative;">
                        <p class="menuheader">Filters</p>
                        <div id="mainfiltersinner" style="width:calc(100% - 20px);height:100%;background-color:#1a1a1a;border-radius:20px;margin-bottom:10px;"></div>
                    </div>
                    <div style="height:1%;"></div>
                    <div id="mainsort" class="maincenter" style="width:100%;height:49.5%;background-image:linear-gradient(120deg, #555555, #1a1a1a);border-radius:20px;position:relative;">
                        <p class="menuheader">Sort</p>
                        <div id="mainsortinner" style="width:calc(100% - 20px);height:100%;background-color:#1a1a1a;border-radius:20px;margin-bottom:10px;overflow-y:auto;"></div>
                    </div>
                </div>
                <div id="mainresults" class="maincenter" style="width:55%;height:100%;background-image:linear-gradient(120deg, #555555, #1a1a1a);border-radius:20px;position:relative;">
                    <p class="menuheader">Search</p>
                    <div id="mainresultsinner" style="width:calc(100% - 20px);height:100%;background-color:#1a1a1a;border-radius:20px;margin-bottom:10px;overflow-y:scroll;"></div>
                </div>
            </div>
        </div>
        <div id="footer" style="flex:1;position:relative;">
            <p class="center" style="margin:0px;">Made With ðŸ§  By <a href="https://aaronskeels.work/" style="color:#1ed760">Aaron Skeels</a></p>
        </div>
    </div>
    <div id="filterdropdownhideout" style="visibility:hidden;width:0px;height:0px;overflow:hidden;"></div>
    <script>
        let vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);
        let vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);
        //
        if (true) {
            let fontFile = new FontFace("Sposhify", "url(/static/font/GothamMedium.ttf)");
            document.fonts.add(fontFile);
            fontFile.load();
        }
        // Header info
        let album_info, artist_info, track_info, listen_history_info, spotifyid_displayname_info;
        load_data() //Load Database Information
        .then(() => {
            console.log("Info Loaded");
            // Generate data conversion maps
            generate_albumspotifyid_to_name();
            generate_artistspotifyid_to_name();
            generate_trackhashid_to_name();
            //
            for (let [spotifyid,displayname] of Object.entries(spotifyid_displayname_info)) {
                generate_account_card(spotifyid,displayname);
            }
            generate_add_account_card();
            generate_filter_card("Filter Song Name", "trackname", "text:Song Name");
            generate_filter_card("Filter Artist Name", "artistname", "text:Artist Name");
            generate_filter_card("Filter Album Name", "albumname", "text:Album Name");
            generate_sort_card("Chronological", "timestamp", true, 1);
            generate_sort_card("Song Play Count", "trackplaycount", false, 1);
            generate_sort_card("Artist Play Count", "artistplaycount", false, 1);
            generate_sort_card("Album Play Count", "albumplaycount", false, 1);
            generate_sort_card("Song Name", "trackname", false, 1);
            generate_sort_card("Artist Name", "artistname", false, 1);
            generate_sort_card("Album Name", "albumname", false, 1);
            updateResultsWithFilters();
        });
        // Retrieve database information
        async function get_album_info() {
            return await fetch("/datapullalbum", {method: 'POST',headers: {'Content-Type': 'application/json'},body: ""})
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(jsonData => {
                    return jsonData;
                })
                .catch(error => {
                    // Handle errors
                    console.error('There was a problem with the fetch operation:', error);
                    return null;
                });
        }
        async function get_artist_info() {
            return await fetch("/datapullartist", {method: 'POST',headers: {'Content-Type': 'application/json'},body: ""})
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(jsonData => {
                    return jsonData;
                })
                .catch(error => {
                    // Handle errors
                    console.error('There was a problem with the fetch operation:', error);
                    return null;
                });
        }
        async function get_track_info() {
            return await fetch("/datapulltrack", {method: 'POST',headers: {'Content-Type': 'application/json'},body: ""})
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(jsonData => {
                    return jsonData;
                })
                .catch(error => {
                    // Handle errors
                    console.error('There was a problem with the fetch operation:', error);
                    return null;
                });
        }
        async function get_listen_history_info() {
            return await fetch("/datapulllisten", {method: 'POST',headers: {'Content-Type': 'application/json'},body: ""})
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(jsonData => {
                    return jsonData;
                })
                .catch(error => {
                    // Handle errors
                    console.error('There was a problem with the fetch operation:', error);
                    return null;
                });
        }
        async function get_spotifyid_displayname_info() {
            return await fetch("/datapullspotdisp", {method: 'POST',headers: {'Content-Type': 'application/json'},body: ""})
                .then(response => {
                    if (!response.ok) {
                        throw new Error('Network response was not ok');
                    }
                    return response.json();
                })
                .then(jsonData => {
                    return jsonData;
                })
                .catch(error => {
                    // Handle errors
                    console.error('There was a problem with the fetch operation:', error);
                    return null;
                });
        }
        async function load_data() {
            // Load all data concurrently using Promise.all
            const results = await Promise.all([
                get_album_info(),
                get_artist_info(),
                get_track_info(),
                get_listen_history_info(),
                get_spotifyid_displayname_info()
            ]);
            album_info = results[0];
            artist_info = results[1];
            track_info = results[2];
            listen_history_info = results[3];
            spotifyid_displayname_info = results[4];
        }
        let albumspotifyid_to_name_map = {},artistspotifyid_to_name_map = {},trackhashid_to_name_map = {};
        function generate_albumspotifyid_to_name() {
            for (let lho of listen_history_info) {
                for (let album of album_info) {
                    if (album.spotifyid == lho.albumspotifyid) {
                        albumspotifyid_to_name_map[album.spotifyid] = album.name;
                        break;
                    }
                }
            }
        }
        function generate_artistspotifyid_to_name() {
            for (let lho of listen_history_info) {
                let artistids = lho.artists.replace("[\"","").replace("\"]","").replace("\",\"",",").split(",");
                for (let targetartistid of artistids) {
                    for (let artist of artist_info) {
                        if (artist.spotifyid == targetartistid) {
                            artistspotifyid_to_name_map[artist.spotifyid] = artist.name;
                            break;
                        }
                    }
                }
            }
        }
        function generate_trackhashid_to_name() {
            for (let lho of listen_history_info) {
                for (let track of track_info) {
                    if (track.hashid == lho.trackhashid) {
                        trackhashid_to_name_map[track.hashid] = track.name;
                        break;
                    }
                }
            }
        }
        let trackplaycountinfomap; //trackhashid -> playcount
        let artistplaycountinfomap; //artistspotifyid -> playcount
        let albumplaycountinfomap; //albumspotifyid -> playcount
        function load_playcount_info(data) {
            trackplaycountinfomap = {};
            artistplaycountinfomap = {};
            albumplaycountinfomap = {};
            for (let lho of data) {
                trackplaycountinfomap[lho.trackhashid] = lho.trackhashid in trackplaycountinfomap ? trackplaycountinfomap[lho.trackhashid]+1 : 1;
            }
            //
            for (let lho of data) {
                let artistids = lho.artists.replace("[\"","").replace("\"]","").replace("\",\"",",").split(",");
                for (let artistid of artistids) {
                    artistplaycountinfomap[artistid] = artistid in artistplaycountinfomap ? artistplaycountinfomap[artistid]+1 : 1;
                }
            }
            //
            for (let lho of data) {
                albumplaycountinfomap[lho.albumspotifyid] = lho.albumspotifyid in albumplaycountinfomap ? albumplaycountinfomap[lho.albumspotifyid]+1 : 1;
            }
        }
        // Generate Account Cards
        let FILTER_selectedaccounts_spotifyids = [];
        function generate_account_card(spotifyid, displayname) {
            let root = document.createElement("div");
            root.classList.add("card","accountcard");
            root.dataset.displayname = displayname;
            root.dataset.spotifyid = spotifyid;
            root.onclick = function() {
                let selected = root.classList.contains("selectedaccount");
                if (selected) {
                    root.classList.remove("selectedaccount");
                    FILTER_selectedaccounts_spotifyids = FILTER_selectedaccounts_spotifyids.filter(item => item !== spotifyid);
                } else {
                    root.classList.add("selectedaccount");
                    FILTER_selectedaccounts_spotifyids.push(spotifyid);
                }
                updateResultsWithFilters();
            }
            let innerText = document.createElement("p");
            innerText.classList.add("center");
            innerText.innerText = displayname;
            innerText.style.margin = "0px";
            root.append(innerText);
            mainacctinner.append(root);
        }
        function generate_add_account_card() {
            let root = document.createElement("div");
            root.classList.add("card","accountcard","addaccountcard");
            root.addEventListener("click", () => {window.location.href = "/authorize";});
            let div = document.createElement("div");
            div.classList.add("center");
            root.append(div);
            let plus = document.createElement("span");
            plus.innerText = "+";
            plus.style.margin = "0px";
            div.append(plus);
            mainacctinner.append(root);
        }
        // Generate Filter Cards
        function generate_filter_card(name, desc, options) {
            if (true) {
                let randomid = Math.floor(Math.random() * 1000000000000);
                let root = document.createElement("div");
                root.id = "filterroot_" + randomid;
                root.style.backgroundColor = "black";
                root.style.marginBottom = "5px";
                root.dataset.desc = desc;
                root.dataset.selected = "0";
                let str = `
                <div id="firstrow" style="position:relative;">
                    <input type="checkbox" style="width:25px;height:25px;clip-path:inset(0px round 6px);" onchange="toggle_filter_card_content(${randomid}, this.checked);updateResultsWithFilters();" /><span style="position:absolute;top:50%;transform:translate(0,-50%);">${name}</span>
                </div>`;
                root.innerHTML = str;
                if (options) {
                    let content = document.createElement("div");
                    content.id = "filtercontent_" + randomid;
                    filterdropdownhideout.append(content);
                    for (let option of options.split(",")) {
                        let colonIndex = option.indexOf(":");
                        let key = option.substring(0, colonIndex);
                        let value = option.substring(colonIndex+1);
                        if (key == "html") {
                            content.innerHTML = value;
                        } else if (key == "text") {
                            if (value != "") {
                                let desc = document.createElement("span");
                                desc.innerText = value + " ";
                                content.append(desc);
                            }
                            let input = document.createElement("input");
                            input.type = "text";
                            input.addEventListener("blur", (event) => {updateResultsWithFilters()});
                            input.addEventListener("keydown", (event) => {if (event.key == "Enter") updateResultsWithFilters();});
                            content.append(input);
                        }
                    }
                }
                mainfiltersinner.append(root);
            }
        }
        function toggle_filter_card_content(randomid, if_do_show) {
            if (if_do_show) {
                let child;
                for (let c of filterdropdownhideout.childNodes) {
                    if (c.id == "filtercontent_" + randomid) {
                        child = c;
                        break;
                    }
                }
                let root = document.getElementById("filterroot_" + randomid);
                root.append(child);
                root.dataset.selected = "1";
            } else {
                let root = document.getElementById("filterroot_" + randomid);
                root.dataset.selected = "0";
                let child = root.children[1];
                filterdropdownhideout.append(child);
            }
        }
        // Generate Sort Cards
        function generate_sort_card(displayname, sortid, isdefault, defaultmultiplier) {
            let root = document.createElement("div");
            root.id = "SORTID_" + sortid;
            root.classList.add("card","sortcard");
            if (isdefault) {
                root.classList.add("selectedsort" + defaultmultiplier);
                SORT_sortbyid = sortid;
                SORT_incordecmultiplier = defaultmultiplier;
            }
            root.onclick = function() {
                if (SORT_sortbyid == sortid) {
                    root.classList.remove("selectedsort" + SORT_incordecmultiplier);
                    SORT_incordecmultiplier = -SORT_incordecmultiplier;
                    root.classList.add("selectedsort" + SORT_incordecmultiplier);
                } else {
                    document.getElementById("SORTID_" + SORT_sortbyid).classList.remove("selectedsort" + SORT_incordecmultiplier);
                    SORT_sortbyid = sortid;
                    SORT_incordecmultiplier = 1;
                    root.classList.add("selectedsort" + SORT_incordecmultiplier);
                }
                updateResultsWithFilters();
            }
            let innerText = document.createElement("p");
            innerText.classList.add("center");
            innerText.innerText = displayname;
            innerText.style.margin = "0px";
            root.append(innerText);
            mainsortinner.append(root);
        }
        // Filtering Functions
        //Fundamentally, structure of interpreter will be an array of array of expressions
        // function EXPRINTERPRETER_getOrGroups(expr, group) {
        //     console.log("OR: " + expr);
        //     expr = expr.trim();
        //     while (expr.includes("|")) {
        //         let orindex = expr.indexOf("|");
        //         let leftexpr = expr.substring(0,orindex);
        //         let lchildgroup = [];
        //         EXPRINTERPRETER_getParenthesisGroups(leftexpr,lchildgroup);
        //         if (lchildgroup.length != 0) group.push(lchildgroup);
        //         let rightexpr = expr.substring(orindex+1);
        //         let rchildgroup = [];
        //         EXPRINTERPRETER_getParenthesisGroups(rightexpr,rchildgroup);
        //         if (rchildgroup.length != 0) group.push(rchildgroup);
        //         console.log("OR Left (" + leftexpr + ")    :: Right (" + rightexpr + ")");
        //         expr = "";
        //     }
        //     if (expr != "") {
        //         group.push(expr);
        //     }
        // }
        // function EXPRINTERPRETER_getAndGroups(expr, group) {
        //     console.log("AND: " + expr);
        //     expr = expr.trim();
        //     while (expr.includes("&")) {
        //         let andindex = expr.indexOf("&");
        //         let orindex = expr.indexOf("|");
        //         let leftexpr = expr.substring(0,andindex);
        //         EXPRINTERPRETER_getParenthesisGroups(leftexpr,group);
        //         let rightexpr = expr.substring(andindex+1);
        //         EXPRINTERPRETER_getParenthesisGroups(rightexpr,group);
        //         expr = "";
        //     }
        //     if (expr != "")
        //         EXPRINTERPRETER_getOrGroups(expr,group);
        // }
        // function EXPRINTERPRETER_getParenthesisGroups(expr, group) {
        //     console.log("(): " + expr);
        //     expr = expr.trim();
        //     while (expr.startsWith("(")) {
        //         let closingParenthesisIndex = expr.indexOf(")");
        //         if (closingParenthesisIndex == -1)
        //             break;
        //         let newgroup = [];
        //         group.push(newgroup);
        //         EXPRINTERPRETER_getParenthesisGroups(expr.substring(1,closingParenthesisIndex), newgroup);
        //         expr = expr.substring(closingParenthesisIndex+1);
        //     }
        //     if (expr != "")
        //         EXPRINTERPRETER_getAndGroups(expr, group);
        // }
        function EXPRINTERPRETER_handleParen(expr, index_openParen, index_closedParen, group) {
            let leftexpr = expr.substring(index_openParen+1, index_closedParen);
            let lnewgroup = [];
            EXPRINTERPRETER_handleExpression(leftexpr, lnewgroup);
            if (lnewgroup.length != 0) group.push(lnewgroup);
            let rightexpr = expr.substring(index_closedParen+1);
            let rnewgroup = [];
            EXPRINTERPRETER_handleExpression(rightexpr, rnewgroup);
            if (rnewgroup.length != 0) group.push(rnewgroup);
        }
        function EXPRINTERPRETER_handleAnd(expr, index_and, group) {
            let leftexpr = expr.substring(0, index_and);
            EXPRINTERPRETER_handleExpression(leftexpr, group);
            let rightexpr = expr.substring(index_and+1);
            EXPRINTERPRETER_handleExpression(rightexpr, group);
        }
        function EXPRINTERPRETER_handleOr(expr, index_or, group) {
            let leftexpr = expr.substring(0, index_or);
            let lnewgroup = [];
            EXPRINTERPRETER_handleExpression(leftexpr, lnewgroup);
            if (lnewgroup.length != 0) group.push(lnewgroup);
            let rightexpr = expr.substring(index_or+1);
            let rnewgroup = [];
            EXPRINTERPRETER_handleExpression(rightexpr, rnewgroup);
            if (rnewgroup.length != 0) group.push(rnewgroup);
        }
        function EXPRINTERPRETER_handleExpression(expr, group) {
            let index_openParen = expr.indexOf("(");
            index_openParen = index_openParen == -1 ? 9999999999 : index_openParen;
            let index_closedParen = expr.indexOf(")");
            index_closedParen = index_closedParen == -1 ? 9999999999 : index_closedParen;
            let index_and = expr.indexOf("&");
            index_and = index_and == -1 ? 9999999999 : index_and;
            let index_or = expr.indexOf("|");
            index_or = index_or == -1 ? 9999999999 : index_or;
            if (index_openParen != 9999999999 && index_openParen < index_and && index_openParen < index_or && (index_openParen < index_closedParen && index_closedParen != 9999999999))
                EXPRINTERPRETER_handleParen(expr, index_openParen, index_closedParen, group);
            else if (index_and != 9999999999 && index_and < index_openParen && index_and < index_or)
                EXPRINTERPRETER_handleAnd(expr, index_and, group);
            else if (index_or != 9999999999 && index_or < index_openParen && index_or < index_and)
                EXPRINTERPRETER_handleOr(expr, index_or, group);
            else
                if(expr != "") group.push(expr);
        }
        function filterUser(spotifyidarray, data) {
            return data.filter(item => spotifyidarray.includes(item.spotifyid));
        }
        function filterTrackName(expression, data) {
            if (expression == "")
                return data;
            // Helper function to handle logical operations
            function evaluate(tokens) {
                if (tokens.length === 1) {
                    // Base case: Single token is either true or false based on data
                    // const word = tokens[0].replace(/"/g, '').trim(); // Remove quotes
                    const word = tokens[0].replace(/"/g, ''); // Remove quotes
                    return item => trackhashid_to_name_map[item.trackhashid].toLowerCase().includes(word.toLowerCase());
                }

                // Check for OR ('|') precedence
                let orTokens = [];
                let currentAndTokens = [];
                let insideParenthesis = 0;
                let startIndex = 0;

                // Split based on OR operator but handle parentheses nesting
                for (let i = 0; i < tokens.length; i++) {
                    if (tokens[i] === "(") insideParenthesis++;
                    if (tokens[i] === ")") insideParenthesis--;
                    if (insideParenthesis === 0 && tokens[i] === "|") {
                        orTokens.push(tokens.slice(startIndex, i));
                        startIndex = i + 1;
                    }
                }

                if (orTokens.length === 0) {
                    orTokens.push(tokens.slice(startIndex)); // If no OR was found, use the whole token list
                }

                // Recursively evaluate AND expressions within OR groups
                return item => {
                    return orTokens.some(orToken => {
                        // Evaluate AND expressions inside OR tokens
                        const andConditions = orToken.join(" ").split("&").map(s => s.trim());
                        return andConditions.every(cond => evaluate([cond])(item));
                    });
                };
            }

            // Tokenize expression (split by spaces, handle operators & parentheses)
            function tokenize(expr) {
                const regex = /(\&|\|)|(\(|\))/g;
                return expr.replace(/\s+/g, ' ').split(regex).filter(Boolean).map(s => s.trim());
            }

            // Parse and evaluate expression
            const tokens = tokenize(expression);
            const evaluateTokens = evaluate(tokens);
            
            // Apply evaluation to the artistname of each object in the dataset
            return data.filter(item => evaluateTokens(item));
        }
        function filterTrackNameMyself(expression, data) {
            let rootgroup = [];
            EXPRINTERPRETER_handleExpression(expression, rootgroup);
            // console.log("rootgroup:");
            // console.log(rootgroup);
            //Recurse through children, discovering if they are true or false
            function evaluateIfGroupIsTrue(groupOrString, item) {
                if (groupOrString.length == 0)
                    return true;
                let isArrayOfConditions = Array.isArray(groupOrString) && typeof groupOrString[0] !== 'string';
                if (isArrayOfConditions) {
                    return groupOrString.some(i => evaluateIfGroupIsTrue(i,item));
                }
                let isFinalStringArray = Array.isArray(groupOrString) && typeof groupOrString[0] === 'string';
                if (isFinalStringArray) {
                    return groupOrString.every(i => evaluateIfGroupIsTrue(i,item));
                }
                //Now we know it's a single string to actually check
                let word = groupOrString.toLowerCase();
                return trackhashid_to_name_map[item.trackhashid].toLowerCase().includes(word);
            }
            return data.filter(item => evaluateIfGroupIsTrue(rootgroup, item));
        }
        function filterArtistNameMyself(expression, data) {
            let rootgroup = [];
            EXPRINTERPRETER_handleExpression(expression, rootgroup);
            // console.log("rootgroup:");
            // console.log(rootgroup);
            //Recurse through children, discovering if they are true or false
            function evaluateIfGroupIsTrue(groupOrString, item) {
                if (groupOrString.length == 0)
                    return true;
                let isArrayOfConditions = Array.isArray(groupOrString) && typeof groupOrString[0] !== 'string';
                if (isArrayOfConditions) {
                    return groupOrString.some(i => evaluateIfGroupIsTrue(i,item));
                }
                let isFinalStringArray = Array.isArray(groupOrString) && typeof groupOrString[0] === 'string';
                if (isFinalStringArray) {
                    return groupOrString.every(i => evaluateIfGroupIsTrue(i,item));
                }
                //Now we know it's a single string to actually check
                let word = groupOrString;
                let artistids = item.artists.replace("[\"","").replace("\"]","").replace("\",\"",",").split(",");
                let anything_found_flag = false;
                for (let artistid of artistids) {
                    let artistname = artistspotifyid_to_name_map[artistid].toLowerCase();
                    if (artistname.includes(word.toLowerCase())) {
                        anything_found_flag = true;
                        break;
                    }
                }
                return anything_found_flag;
            }
            return data.filter(item => evaluateIfGroupIsTrue(rootgroup, item));
        }
        function filterAlbumNameMyself(expression, data) {
            let rootgroup = [];
            EXPRINTERPRETER_handleExpression(expression, rootgroup);
            // console.log("rootgroup:");
            // console.log(rootgroup);
            //Recurse through children, discovering if they are true or false
            function evaluateIfGroupIsTrue(groupOrString, item) {
                if (groupOrString.length == 0)
                    return true;
                let isArrayOfConditions = Array.isArray(groupOrString) && typeof groupOrString[0] !== 'string';
                if (isArrayOfConditions) {
                    return groupOrString.some(i => evaluateIfGroupIsTrue(i,item));
                }
                let isFinalStringArray = Array.isArray(groupOrString) && typeof groupOrString[0] === 'string';
                if (isFinalStringArray) {
                    return groupOrString.every(i => evaluateIfGroupIsTrue(i,item));
                }
                //Now we know it's a single string to actually check
                let word = groupOrString.toLowerCase();
                return albumspotifyid_to_name_map[item.albumspotifyid].toLowerCase().includes(word);
            }
            return data.filter(item => evaluateIfGroupIsTrue(rootgroup, item));
        }
        function filterArtistName(expression, data) {
            if (expression == "")
                return data;
            
            // Helper function to handle logical operations
            function evaluate(tokens) {
                if (tokens.length === 1) {
                    const word = tokens[0].replace(/"/g, ''); // Remove quotes
                    return item => {
                        let artistids = item.artists.replace("[\"","").replace("\"]","").replace("\",\"",",").split(",");
                        let anything_found_flag = false;
                        for (let artistid of artistids) {
                            let artistname = artistspotifyid_to_name_map[artistid].toLowerCase();
                            if (artistname.includes(word.toLowerCase())) {
                                anything_found_flag = true;
                                break;
                            }
                        }
                        return anything_found_flag;
                    }
                }

                // Check for OR ('|') precedence
                let orTokens = [];
                let currentAndTokens = [];
                let insideParenthesis = 0;
                let startIndex = 0;

                // Split based on OR operator but handle parentheses nesting
                for (let i = 0; i < tokens.length; i++) {
                    if (tokens[i] === "(") insideParenthesis++;
                    if (tokens[i] === ")") insideParenthesis--;
                    if (insideParenthesis === 0 && tokens[i] === "|") {
                        orTokens.push(tokens.slice(startIndex, i));
                        startIndex = i + 1;
                    }
                }

                if (orTokens.length === 0) {
                    orTokens.push(tokens.slice(startIndex)); // If no OR was found, use the whole token list
                }

                // Recursively evaluate AND expressions within OR groups
                return item => {
                    return orTokens.some(orToken => {
                        const andConditions = orToken.join(" ").split("&").map(s => s.trim());
                        return andConditions.every(cond => evaluate([cond])(item));
                    });
                };
            }

            // Tokenize expression (split by spaces, handle operators & parentheses)
            function tokenize(expr) {
                const regex = /(\&|\|)|(\(|\))/g;
                return expr.replace(/\s+/g, ' ').split(regex).filter(Boolean).map(s => s.trim());
            }

            // Parse and evaluate expression
            const tokens = tokenize(expression);
            const evaluateTokens = evaluate(tokens);
            
            // Apply evaluation to the artistname of each object in the dataset
            return data.filter(item => evaluateTokens(item));
        }
        function filterAlbumName(expression, data) {
            if (expression == "")
                return data;
            // Helper function to handle logical operations
            function evaluate(tokens) {
                if (tokens.length === 1) {
                    // Base case: Single token is either true or false based on data
                    // const word = tokens[0].replace(/"/g, '').trim(); // Remove quotes
                    const word = tokens[0].replace(/"/g, ''); // Remove quotes
                    return item => {
                        let albumname = albumspotifyid_to_name_map[item.albumspotifyid];
                        if (!albumname)
                            albumname = "";
                        return albumname.toLowerCase().includes(word.toLowerCase());
                    }
                }

                // Check for OR ('|') precedence
                let orTokens = [];
                let currentAndTokens = [];
                let insideParenthesis = 0;
                let startIndex = 0;

                // Split based on OR operator but handle parentheses nesting
                for (let i = 0; i < tokens.length; i++) {
                    if (tokens[i] === "(") insideParenthesis++;
                    if (tokens[i] === ")") insideParenthesis--;
                    if (insideParenthesis === 0 && tokens[i] === "|") {
                        orTokens.push(tokens.slice(startIndex, i));
                        startIndex = i + 1;
                    }
                }

                if (orTokens.length === 0) {
                    orTokens.push(tokens.slice(startIndex)); // If no OR was found, use the whole token list
                }

                // Recursively evaluate AND expressions within OR groups
                return item => {
                    return orTokens.some(orToken => {
                        // Evaluate AND expressions inside OR tokens
                        const andConditions = orToken.join(" ").split("&").map(s => s.trim());
                        return andConditions.every(cond => evaluate([cond])(item));
                    });
                };
            }

            // Tokenize expression (split by spaces, handle operators & parentheses)
            function tokenize(expr) {
                const regex = /(\&|\|)|(\(|\))/g;
                return expr.replace(/\s+/g, ' ').split(regex).filter(Boolean).map(s => s.trim());
            }

            // Parse and evaluate expression
            const tokens = tokenize(expression);
            const evaluateTokens = evaluate(tokens);
            
            // Apply evaluation to the artistname of each object in the dataset
            return data.filter(item => evaluateTokens(item));
        }
        let SORT_sortbyid; //timestamp
        let SORT_incordecmultiplier; //1
        function updateResultsWithFilters() {
            let attachpointelem = document.getElementById("mainresultsinner");
            attachpointelem.innerHTML = ""; //Reset the results html
            //Stage 1 Filtration
            let filtered_data = listen_history_info.map(obj => ({ ...obj }));;
            filtered_data = FILTER_selectedaccounts_spotifyids.length != 0 ? filterUser(FILTER_selectedaccounts_spotifyids, filtered_data) : filtered_data;
            //Filter functions to be used in sorting
            function removeDuplicateTrackHashId(data) {
                let handledset = [];
                let newdata = [];
                for (let lho of data) {
                    if (handledset.includes(lho.trackhashid))
                        continue;
                    newdata.push(lho);
                    handledset.push(lho.trackhashid);
                }
                return newdata;
            }
            function removeDuplicateArtistSpotifyId(data) {
                let handledset = [];
                let newdata = [];
                for (let lho of data) {
                    if (handledset.includes(lho.artists)) {
                        // console.log("Skipping: " + lho.artists);
                        continue;
                    }
                    newdata.push(lho);
                    handledset.push(lho.artists);
                }
                return newdata;
            }
            function removeDuplicateTrackAndArtistName(data) {
                let handledset = [];
                let newdata = [];
                for (let lho of data) {
                    if (handledset.includes(lho.trackhashid + lho.artists))
                        continue;
                    newdata.push(lho);
                    handledset.push(lho.trackhashid + lho.artists);
                }
                return newdata;
            }
            function removeDuplicateAlbumSpotifyId(data) {
                let handledset = [];
                let newdata = [];
                for (let lho of data) {
                    if (handledset.includes(lho.albumspotifyid))
                        continue;
                    newdata.push(lho);
                    handledset.push(lho.albumspotifyid);
                }
                return newdata;
            }
            //Load playcount info
            load_playcount_info(filtered_data);
            //Sort data
            let special_space = "&nbsp;&nbsp;&nbsp;&nbsp;";
            let special_divider = special_space + "|" + special_space;
            if (true) {
                if (SORT_sortbyid == "timestamp") {
                    filtered_data.sort((a,b) => a.timestamp > b.timestamp ? -1*SORT_incordecmultiplier : (a.timestamp < b.timestamp ? 1*SORT_incordecmultiplier : 0));
                    for (let lho of filtered_data) {
                        let date = new Date(lho.timestamp);
                        let hours = date.getHours();
                        const minutes = date.getMinutes();
                        const period = hours >= 12 ? 'PM' : 'AM';
                        hours = hours % 12;
                        hours = hours ? hours : 12; // Handle midnight (0 should become 12)
                        // Format minutes to always be two digits
                        const formattedMinutes = minutes.toString().padStart(2, '0');
                        // Format the date to "hour:minute AM/PM month-day-year"
                        const formattedDate = `${hours}:${formattedMinutes} ${period} ${date.getMonth() + 1}-${date.getDate()}-${date.getFullYear()}`;
                        if (albumspotifyid_to_name_map[lho.albumspotifyid])
                            lho.primaryhtmlstring = `%counter%. %trackname%${special_divider}%artiststring%${special_divider}%albumname%`;
                        else
                            lho.primaryhtmlstring = `%counter%. %trackname%${special_divider}%artiststring%`;
                        lho.secondaryhtmlstring = special_space + formattedDate;
                    }
                } else if (SORT_sortbyid == "trackplaycount") {
                    filtered_data = removeDuplicateTrackHashId(filtered_data);
                    filtered_data.sort((a,b) => {
                        let aval = trackplaycountinfomap[a.trackhashid];
                        let bval = trackplaycountinfomap[b.trackhashid];
                        return aval > bval ? -1*SORT_incordecmultiplier : (aval < bval ? 1*SORT_incordecmultiplier : 0);
                    });
                    for (let lho of filtered_data) {
                        if (albumspotifyid_to_name_map[lho.albumspotifyid])
                            lho.primaryhtmlstring = `%counter%. %trackname%${special_divider}%artiststring%${special_divider}%albumname%`;
                        else
                            lho.primaryhtmlstring = `%counter%. %trackname%${special_divider}%artiststring%`;
                        lho.secondaryhtmlstring = special_space + trackplaycountinfomap[lho.trackhashid] + " Play(s)";
                    }
                } else if (SORT_sortbyid == "artistplaycount") {
                    //This one is very special. Because there can be multiple artists per song, and people would want to know both independently
                    // in this sorted list, we need to duplicate/split the data per artist. THEN we will sort.
                    //First, duplicate/split
                    for (let i = 0;i < filtered_data.length;i++) {
                        let lho = filtered_data[i];
                        if (lho.artists.length == 1)
                            continue;
                        let artistsarray = lho.artists.replace("[\"","").replace("\"]","").replace("\",\"",",").split(",");
                        // let artists = lho.artists;
                        lho.artists = `["${artistsarray[0]}"]`;
                        lho.primaryhtmlstring = `%counter%. %artiststring%`;
                        lho.secondaryhtmlstring = special_space + artistplaycountinfomap[artistsarray[0]] + " Plays";
                        for (let i = 0;i < artistsarray.length;i++) {
                            if (i == 0)
                                continue;
                            let artist = artistsarray[i];
                            let clone = Object.assign({}, lho);
                            clone.artists = `["${artist}"]`;
                            clone.secondaryhtmlstring = special_space + artistplaycountinfomap[artist] + " Plays";
                            filtered_data.push(clone);
                        }
                    }
                    //Second, remove listenhistoryobjects with duplicate artists
                    filtered_data = removeDuplicateArtistSpotifyId(filtered_data);
                    //Third, now we sort
                    filtered_data.sort((a,b) => {
                        let aartist = a.artists.replace("[\"","").replace("\"]","").replace("\",\"",",");
                        let bartist = b.artists.replace("[\"","").replace("\"]","").replace("\",\"",",");
                        let aval = artistplaycountinfomap[aartist];
                        let bval = artistplaycountinfomap[bartist];
                        return aval > bval ? -1*SORT_incordecmultiplier : (aval < bval ? 1*SORT_incordecmultiplier : 0)
                    });
                } else if (SORT_sortbyid == "albumplaycount") {
                    //Remove all entries without albums
                    filtered_data = filtered_data.filter((item) => item.albumspotifyid in albumspotifyid_to_name_map);
                    //Remove dupes
                    filtered_data = removeDuplicateAlbumSpotifyId(filtered_data);
                    //
                    filtered_data.sort((a,b) => {
                        let aval = albumplaycountinfomap[a.albumspotifyid];
                        let bval = albumplaycountinfomap[b.albumspotifyid];
                        return aval > bval ? -1*SORT_incordecmultiplier : (aval < bval ? 1*SORT_incordecmultiplier : 0);
                    });
                    for (let lho of filtered_data) {
                        let artiststring = "";
                        let artistids = "";
                        for (let album of album_info) {
                            if (album.spotifyid == lho.albumspotifyid) {
                                artistids = album.artists.replace("[\"","").replace("\"]","").replace("\",\"",",").split(",");
                                break;
                            }
                        }
                        for (let artistid of artistids) {
                            artiststring += artistspotifyid_to_name_map[artistid] + " & ";
                        }
                        artiststring = artiststring.substring(0, artiststring.length-3);
                        lho.primaryhtmlstring = `%counter%. %albumname%${special_divider}${artiststring}`;
                        lho.secondaryhtmlstring = special_space + albumplaycountinfomap[lho.albumspotifyid] + " Play(s)";
                    }
                } else if (SORT_sortbyid == "trackname") {
                    filtered_data = removeDuplicateTrackHashId(filtered_data);
                    filtered_data.sort((a,b) => {
                        let aval = trackhashid_to_name_map[a.trackhashid].toLowerCase();
                        let bval = trackhashid_to_name_map[b.trackhashid].toLowerCase();
                        return aval > bval ? 1*SORT_incordecmultiplier : (aval < bval ? -1*SORT_incordecmultiplier : 0)
                    });
                    for (let lho of filtered_data) {
                        if (albumspotifyid_to_name_map[lho.albumspotifyid])
                            lho.primaryhtmlstring = `%counter%. %trackname%${special_divider}%artiststring%${special_divider}%albumname%`;
                        else
                            lho.primaryhtmlstring = `%counter%. %trackname%${special_divider}%artiststring%`;
                        lho.secondaryhtmlstring = special_space + trackplaycountinfomap[lho.trackhashid] + " Play(s)";
                    }
                } else if (SORT_sortbyid == "artistname") {
                    //This one is very special. Because there can be multiple artists per song, and people would want to know both independently
                    // in this sorted list, we need to duplicate/split the data per artist. THEN we will sort.
                    //First, duplicate/split
                    for (let i = 0;i < filtered_data.length;i++) {
                        let lho = filtered_data[i];
                        if (lho.artists.length == 1)
                            continue;
                        let artistsarray = lho.artists.replace("[\"","").replace("\"]","").replace("\",\"",",").split(",");
                        // let artists = lho.artists;
                        lho.artists = `["${artistsarray[0]}"]`;
                        lho.primaryhtmlstring = `%counter%. %artiststring%`;
                        lho.secondaryhtmlstring = special_space + artistplaycountinfomap[artistsarray[0]] + " Plays";
                        for (let i = 0;i < artistsarray.length;i++) {
                            if (i == 0)
                                continue;
                            let artist = artistsarray[i];
                            let clone = Object.assign({}, lho);
                            clone.artists = `["${artist}"]`;
                            clone.secondaryhtmlstring = special_space + artistplaycountinfomap[artist] + " Plays";
                            filtered_data.push(clone);
                        }
                    }
                    //Second, remove listenhistoryobjects with duplicate artists
                    filtered_data = removeDuplicateArtistSpotifyId(filtered_data);
                    //Third, now we sort
                    filtered_data.sort((a,b) => {
                        let aartist = a.artists.replace("[\"","").replace("\"]","").replace("\",\"",",");
                        let bartist = b.artists.replace("[\"","").replace("\"]","").replace("\",\"",",");
                        let aval = artistspotifyid_to_name_map[aartist].toLowerCase();
                        let bval = artistspotifyid_to_name_map[bartist].toLowerCase();
                        return aval > bval ? 1*SORT_incordecmultiplier : (aval < bval ? -1*SORT_incordecmultiplier : 0)
                    });
                } else if (SORT_sortbyid == "albumname") {
                    filtered_data = removeDuplicateAlbumSpotifyId(filtered_data);
                    filtered_data.sort((a,b) => {
                        let aname = albumspotifyid_to_name_map[a.albumspotifyid];
                        let bname = albumspotifyid_to_name_map[b.albumspotifyid];
                        if (!aname && !bname) {
                            return 0;
                        } else if (!aname) {
                            return 1;
                        } else if (!bname) {
                            return -1;
                        }
                        let aval = aname.toLowerCase();
                        let bval = albumspotifyid_to_name_map[b.albumspotifyid].toLowerCase();
                        return aval > bval ? 1*SORT_incordecmultiplier : (aval < bval ? -1*SORT_incordecmultiplier : 0)
                    });
                    for (let lho of filtered_data) {
                        let artiststring = "";
                        let artistids = "";
                        for (let album of album_info) {
                            if (album.spotifyid == lho.albumspotifyid) {
                                artistids = album.artists.replace("[\"","").replace("\"]","").replace("\",\"",",").split(",");
                                break;
                            }
                        }
                        for (let artistid of artistids) {
                            artiststring += artistspotifyid_to_name_map[artistid] + " & ";
                        }
                        artiststring = artiststring.substring(0, artiststring.length-3);
                        lho.primaryhtmlstring = `%counter%. %albumname%${special_divider}${artiststring}`;
                        lho.secondaryhtmlstring = special_space + albumplaycountinfomap[lho.albumspotifyid] + " Play(s)";
                    }
                }
            }
            //Stage 2 Filtration
                //trackname
                let trackname = "";
            for (let filterroot of mainfiltersinner.children) {
                if (filterroot.dataset.desc == "trackname" && filterroot.dataset.selected == "1") {
                    trackname = filterroot.children[1].children[1].value;
                    break;
                }
            }
            filtered_data = trackname != "" ? filterTrackNameMyself(trackname, filtered_data) : filtered_data;
            console.log("---");
                //artistname
            let artistname = "";
            for (let filterroot of mainfiltersinner.children) {
                if (filterroot.dataset.desc == "artistname" && filterroot.dataset.selected == "1") {
                    artistname = filterroot.children[1].children[1].value;
                    break;
                }
            }
            filtered_data = artistname != "" ? filterArtistNameMyself(artistname, filtered_data) : filtered_data;
                //albumname
            let albumname = "";
            for (let filterroot of mainfiltersinner.children) {
                if (filterroot.dataset.desc == "albumname" && filterroot.dataset.selected == "1") {
                    albumname = filterroot.children[1].children[1].value;
                    break;
                }
            }
            filtered_data = albumname != "" ? filterAlbumNameMyself(albumname, filtered_data) : filtered_data;
            //Create html results from filtered & sorted data
            let counter = 0;
            function handle_placeholders(string, lho, counter) {
                let artiststring = "";
                let artistids = lho.artists.replace("[\"","").replace("\"]","").replace("\",\"",",").split(",");
                for (let artistid of artistids)
                    artiststring += artistspotifyid_to_name_map[artistid] + " & ";
                artiststring = artiststring.substring(0, artiststring.length-3);
                return string
                    .replace("%counter%", counter)
                    .replace("%trackname%", trackhashid_to_name_map[lho.trackhashid])
                    .replace("%artiststring%", artiststring)
                    .replace("%albumname%", albumspotifyid_to_name_map[lho.albumspotifyid]);
            }
            for (let lho of filtered_data) {
                counter++;
                let artistids = lho.artists.replace("[\"","").replace("\"]","").replace("\",\"",",").split(",");
                let artistnames = [];
                for (let artistid of artistids) {
                    artistnames.push(artistspotifyid_to_name_map[artistid]);
                }
                //
                let trackname = trackhashid_to_name_map[lho.trackhashid];
                let albumname = albumspotifyid_to_name_map[lho.albumspotifyid];
                let trackplaycount = trackplaycountinfomap[lho.trackhashid];
                //
                let root = document.createElement("p");
                root.style.marginBottom = "0px";
                // let str = counter + ". " + trackname + "&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;";
                // for (let artistname of artistnames)
                //     str += artistname + " & ";
                // str = str.substring(0, str.length-3);
                // if (albumname)
                //     str += "&nbsp;&nbsp;&nbsp;&nbsp;|&nbsp;&nbsp;&nbsp;&nbsp;" + albumname;
                root.innerHTML = handle_placeholders(lho.primaryhtmlstring, lho, counter);
                attachpointelem.append(root);
                if (lho.secondaryhtmlstring != "") { //If the sorting leads to a special value being attached on the second line of each song
                    let specialvalue = document.createElement("span");
                    specialvalue.innerHTML = handle_placeholders(lho.secondaryhtmlstring, lho, counter);
                    attachpointelem.append(specialvalue);
                }
            }
            let fillerdiv = document.createElement("div");
            fillerdiv.style.height = "20px";
            attachpointelem.append(fillerdiv);
        }
    </script>
</body>
</html>